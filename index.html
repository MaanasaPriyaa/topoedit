<!DOCTYPE html>
<meta charset="utf-8">
<style>

html,
body {
  margin: 0;
  overflow: hidden;
}

#help {
  position: fixed;
  font: 18px "Helvetica Neue";
  top: 20%;
  left: 50%;
  transform: translate(-50%,0);
  margin: 0;
}

#canvas {
  position: fixed;
  top: 0;
  left: 0;
}

.mesh path {
  fill: none;
  stroke: #000;
  vector-effect: non-scaling-stroke;
}

.mesh path:hover {
  stroke: red;
  stroke-width: 3px;
}

#underlay {
  fill: none;
  pointer-events: all;
}

</style>
<svg id="canvas">
  <rect id="underlay" width="100%" height="100%"></rect>
</svg>
<div id="help">[drag a TopoJSON file here]</div>
<script src="d3.js"></script>
<script src="topojson.js"></script>
<script>

var width,
    height;

d3.select(document)
    .on("dragenter", dragentered)
    .on("dragleave", dragleaved)
    .on("dragover", dragovered)
    .on("drop", dropped);

d3.select(window)
    .on("resize", resized);

var zoom = d3.behavior.zoom()
    .on("zoom", zoomed);

var canvas = d3.select("#canvas").call(zoom),
    arc = d3.select(null),
    help = d3.select("#help");

resized();

if (location.search) d3.json(location.search.slice(1), function(error, json) { if (!error) load(json); });

function dragentered() {
  canvas.style("background", "#eee");
  arc.remove();
  arc = d3.select(null);
  help.text("[now drop]");
}

function dragleaved() {
  canvas.style("background", null);
  help.text("[drag a TopoJSON file here]");
}

function dragovered() {
  d3.event.preventDefault();
}

function dropped() {
  if (!d3.event.dataTransfer.files.length) return dragleaved();
  canvas.style("background", "#ddd");
  help.text("[reading fileâ€¦]");
  d3.event.preventDefault();
  dropread(d3.event.dataTransfer.files[0]);
}

function dropread(file) {
  var reader = new FileReader;
  reader.onload = function() {
    var topology;
    try { topology = JSON.parse(reader.result); } catch (error) { return dropfailed("not a JSON file"); }
    if (typeof topology !== "object" || topology.type !== "Topology") return dropfailed("not a TopoJSON file");
    load(topology);
  };
  reader.onerror = function() {
    dropfailed("unable to read file");
  };
  reader.readAsText(file);
}

function dropfailed(message) {
  dragleaved();
  help.text("[" + message + "; try again?]");
}

function load(topology) {
  help
      .style("display", "none");

  canvas
      .style("background", null);

  var mesh = topojson.mesh(topology),
      transform = transformAbsolute(topology.transform);

  arc = canvas.append("g", "*")
      .attr("class", "mesh");

  arc.append("path")
      .attr("d", d3.geo.pipeline()
          .source(d3.geom.jsonSource)
          .sink(d3.geom.pathSink)
          (mesh));

  // arc.selectAll("path")
  //     .data(topology.arcs.map(function(arc) {
  //       return {
  //         type: "LineString",
  //         coordinates: arc.map(transform)
  //       };
  //     }))
  //   .enter().append("path")
  //     .attr("d", d3.geo.pipeline()
  //         .source(d3.geom.jsonSource)
  //         .sink(d3.geom.pathSink));

  zoomToFit(mesh);
}

function identity(d) {
  return d;
}

function transformAbsolute(transform) {
  if (!transform) return identity;
  var x0,
      y0,
      kx = transform.scale[0],
      ky = transform.scale[1],
      dx = transform.translate[0],
      dy = transform.translate[1];
  return function(point, i) {
    if (!i) x0 = y0 = 0;
    return [
      (x0 += point[0]) * kx + dx,
      (y0 += point[1]) * ky + dy
    ];
  };
}

function zoomToFit(feature) {
  var bounds = d3.geo.pipeline()
      .source(d3.geom.jsonSource)
      .sink(d3.geom.boundsSink)
      (feature);

  var x0 = bounds[0][0],
      y0 = bounds[0][1],
      dx = bounds[1][0] - x0,
      dy = bounds[1][1] - y0;

  var scale = Math.min(width / dx, height / dy) * .95,
      translateX = (width - scale * dx) / 2 - x0 * scale,
      translateY = (height - scale * dy) / 2 - y0 * scale;

  zoom
      .scale(scale)
      .translate([translateX, translateY]);

  canvas
      .call(zoom.event);
}

function zoomed() {
  arc.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
}

function simplify(sink) {
  var x0, y0;
  return {
    polygonStart: function() { sink.polygonStart(); },
    polygonEnd: function() { sink.polygonEnd(); },
    lineStart: function() { sink.lineStart(); x0 = y0 = NaN; },
    lineEnd: function() { sink.lineEnd(); },
    point: function(x, y) {
      if (isNaN(x0) || Math.abs(x - x0) >= 1 || Math.abs(y - y0) >= 1) {
        sink.point(x0 = x, y0 = y);
      }
    }
  };
}

function resized() {
  var newWidth = innerWidth,
      newHeight = innerHeight;

  if (newWidth === width && newHeight === height) return;

  width = newWidth;
  height = newHeight;

  canvas
      .attr("width", width)
      .attr("height", height)
      .call(zoom.event);
}

</script>
